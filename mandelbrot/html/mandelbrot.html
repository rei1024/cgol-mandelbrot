<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="robots" content="noindex" />
        <title>Mandelbrot set</title>
    </head>
    <body>
        <header>
            <h1>Mandelbrot set</h1>
        </header>
        <canvas id="canvas"></canvas>
        <script>
/**
 *
 * @param {bigint} x
 * @param {boolean} xIsNegative
 * @param {bigint} y
 * @param {boolean} yIsNegative
 * @returns
 */
 function addWithSign(x, xIsNegative, y, yIsNegative) {
    if (xIsNegative) {
        if (yIsNegative) {
            return {
                isNegative: true,
                value: x + y,
            }
        } else {
            if (x > y) {
                return {
                    isNegative: true,
                    value: x - y
                }
            } else {
                return {
                    isNegative: false,
                    value: y - x,
                }
            }
        }
    } else {
        if (yIsNegative) {
            if (x > y) {
                return {
                    isNegative: false,
                    value: x - y,
                }
            } else {
                return {
                    isNegative: true,
                    value: y - x
                }
            }
        } else {
            return {
                isNegative: false,
                value: x + y,
            }
        }
    }
}

class WithSign {
    /**
     *
     * @param {bigint} value
     * @param {boolean} isNegative
     */
    constructor(value, isNegative) {
        if (typeof isNegative !== 'boolean') {
            throw new Error('Error')
        }
        if (value < 0n) {
            throw new Error('negative number');
        }
        if (value === 0n && isNegative) {
            isNegative = false;
        }
        /**
         * @private
         * @readonly
         */
        this.value = value;
        /**
         * @private
         * @readonly
         */
        this.isNegative = isNegative;
    }

    /** 0 */
    static zero() {
        return new WithSign(0n, false)
    }

    /**
     * this + other
     * @param {WithSign} other
     * @returns {WithSign}
     */
    add(other) {
        const out = addWithSign(this.value, this.isNegative, other.value, other.isNegative);
        return new WithSign(out.value, out.isNegative);
    }

    /**
     * this - other
     * @param {WithSign} other
     * @returns {WithSign}
     */
    sub(other) {
        return this.add(new WithSign(other.value, !other.isNegative))
    }

    /**
     * -this
     */
    negate() {
        return new WithSign(this.value, !this.isNegative);
    }

    /** +1 */
    succ() {
        return this.add(new WithSign(1n, false))
    }

    /**
     * this * other
     * @param {WithSign} other
     * @returns {WithSign}
     */
    mul(other) {
        return new WithSign(this.value * other.value, this.isNegative != other.isNegative)
    }

    /**
     * |this| > num
     * @param {bigint} num
     */
    absGt(num) {
        return this.value > num;
    }

    /**
     * this >> x
     * @param {bigint} x
     * @returns {WithSign}
     */
    rightShift(x) {
        return new WithSign(this.value >> x, this.isNegative)
    }

    /**
     * 
     * @returns {bigint}
     */
    asBigInt() {
        if (this.isNegative) {
            return -this.value;
        } else {
            return this.value
        }
    }
}

const $canvas = document.querySelector("#canvas");
if (!($canvas instanceof HTMLCanvasElement)) {
    throw new Error('error')
}
const context = $canvas.getContext("2d", { alpha: false });
if (context == null) {
    throw new Error('error')
}

// scale
// Must be a power of 2
const SIZE = 2 ** 6;

// Number of iteration to check divergence
const ITERATION = 32;

$canvas.width = SIZE * 4;
$canvas.height = SIZE * 4;

const DIVERGE_LIMIT = 4n * BigInt(SIZE);

context.fillStyle = "white";
context.fillRect(0, 0, $canvas.width, $canvas.height);

context.fillStyle = "black";

const SIZE_BIGINT = BigInt(SIZE);
const SIZE_LOG2 = BigInt(Math.log2(SIZE)) // throws error then log2 is float

// B2DX, B2DY
let canvasX = 0;
let canvasY = 0;

let cx = new WithSign(SIZE_BIGINT * 2n, true);
let cy = new WithSign(SIZE_BIGINT * 2n, true);

// from -2 to 2
for (let _i = 0; _i < SIZE * 4; _i++) {
    for (let _j = 0; _j < SIZE * 4; _j++) {
        let diverge = false;
        let x = WithSign.zero();
        let y = WithSign.zero();

        for (let k = 0; k < ITERATION; k++) {
            // xSq = x^2 / SIZE
            let xSq = x;
            xSq = xSq.mul(x);
            xSq = xSq.rightShift(SIZE_LOG2)
            // ySq = x^2 / SIZE
            let ySq = y;
            ySq = ySq.mul(y);
            ySq = ySq.rightShift(SIZE_LOG2)
            // const xSqAddYSq = xSq.add(ySq)
            // // x^2 + y^2 > 4
            // if (xSqAddYSq.absGt(DIVERGE_LIMIT)) {
            //     diverge = true;
            //     break;
            // }
            if (xSq.absGt(DIVERGE_LIMIT) || ySq.absGt(DIVERGE_LIMIT)) {
                diverge = true;
                break;
            }
            const xTemp = xSq.sub(ySq).add(cx);
            // y = (2n * x * y) / SIZE_BIGINT + c_y;
            y = y.mul(x);
            y = y.rightShift(SIZE_LOG2 - 1n);
            y = y.add(cy);
            x = xTemp;
        }

        if (!diverge) {
            context.rect(canvasX, canvasY, 1, 1);
            // context.fill();
            // await new Promise(resolve => setTimeout(resolve, 1))
        }
        canvasX += 1;
        cx = cx.succ();
    }

    cx = new WithSign(SIZE_BIGINT * 2n, true);
    cy = cy.succ();

    canvasX = 0;
    canvasY += 1;
}
context.fill();
        </script>
    </body>
</html>
